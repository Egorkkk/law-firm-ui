// Simple offline static server + small write API for filming UI (no build step).
// Run: node server.js
// Open: http://localhost:8081
//
// Adds admin endpoints for real on-disk editing:
//   GET    /api/clients
//   GET    /api/client/:id
//   POST   /api/client
//   PUT    /api/client/:id
//   DELETE /api/client/:id
//
// Notes:
// - id is restricted to c### (e.g. c217)
// - writes are constrained to .../public/assets/clients/* to avoid path traversal

const http = require("http");
const fs = require("fs");
const fsp = require("fs/promises");
const path = require("path");

const PORT = process.env.PORT ? Number(process.env.PORT) : 8081;
const PUBLIC_DIR = path.join(__dirname, "public");

const CLIENTS_JSON = path.join(PUBLIC_DIR, "assets/clients/clients.json");
const DOSSIERS_DIR = path.join(PUBLIC_DIR, "assets/clients/dossiers");
const PHOTOS_DIR = path.join(PUBLIC_DIR, "assets/clients/photos");

const MIME = {
  ".html": "text/html; charset=utf-8",
  ".css": "text/css; charset=utf-8",
  ".js": "application/javascript; charset=utf-8",
  ".json": "application/json; charset=utf-8",
  ".txt": "text/plain; charset=utf-8",
  ".svg": "image/svg+xml",
  ".png": "image/png",
  ".jpg": "image/jpeg",
  ".jpeg": "image/jpeg",
  ".webp": "image/webp",
  ".gif": "image/gif",
  ".mp3": "audio/mpeg",
  ".wav": "audio/wav",
  ".ogg": "audio/ogg",
  ".mp4": "video/mp4",
  ".woff2": "font/woff2"
};

function safeJoin(base, target) {
  const targetPath = path.normalize(path.join(base, target));
  if (!targetPath.startsWith(base)) return null; // prevent path traversal
  return targetPath;
}

function send(res, code, headers, body) {
  res.writeHead(code, headers);
  res.end(body ?? "");
}

function sendJson(res, code, obj) {
  send(res, code, { "Content-Type": "application/json; charset=utf-8", "Cache-Control": "no-cache" }, JSON.stringify(obj));
}

function serveFile(req, res, filePath) {
  fs.stat(filePath, (err, stat) => {
    if (err || !stat.isFile()) {
      return send(res, 404, { "Content-Type": "text/plain; charset=utf-8" }, "Not Found");
    }

    const ext = path.extname(filePath).toLowerCase();
    const mime = MIME[ext] || "application/octet-stream";

    res.writeHead(200, {
      "Content-Type": mime,
      "Cache-Control": "no-cache"
    });

    const stream = fs.createReadStream(filePath);
    stream.on("error", () => {
      if (!res.headersSent) {
        send(res, 500, { "Content-Type": "text/plain; charset=utf-8" }, "Server Error");
      } else {
        res.destroy();
      }
    });
    stream.pipe(res);
  });
}

function isValidClientId(id) {
  return /^c\d{3}$/i.test(String(id || "").trim());
}

function normId(id) {
  return String(id || "").trim().toLowerCase();
}

function computePathsForId(id) {
  const cid = normId(id);
  return {
    dossier: `assets/clients/dossiers/${cid}.html`,
    photo: `assets/clients/photos/${cid}.png`, // later you can switch to .webp in UI
    audio: `assets/clients/audio/${cid}_call.mp3`,
    transcript: `assets/clients/transcripts/${cid}.txt`
  };
}

async function readJsonFile(filePath, fallback) {
  try {
    const s = await fsp.readFile(filePath, "utf8");
    return JSON.parse(s);
  } catch {
    return fallback;
  }
}

async function writeJsonFile(filePath, data) {
  await fsp.mkdir(path.dirname(filePath), { recursive: true });
  const tmp = `${filePath}.tmp`;
  await fsp.writeFile(tmp, JSON.stringify(data, null, 2), "utf8");
  await fsp.rename(tmp, filePath);
}

async function readBodyJson(req, { limitBytes = 1_500_000 } = {}) {
  const chunks = [];
  let total = 0;
  for await (const chunk of req) {
    total += chunk.length;
    if (total > limitBytes) throw new Error("PAYLOAD_TOO_LARGE");
    chunks.push(chunk);
  }
  const raw = Buffer.concat(chunks).toString("utf8").trim();
  if (!raw) return null;
  try {
    return JSON.parse(raw);
  } catch {
    throw new Error("BAD_JSON");
  }
}

function escapeHtml(s) {
  return String(s ?? "")
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");
}

function buildDossierHtml({ id, client, dossier }) {
  const cid = normId(id);
  const num = cid.replace(/^c/i, "");
  const payload = { client, dossier };

  const tl = Array.isArray(dossier?.timeline) ? dossier.timeline : [];
  const timelineHtml = tl.length
    ? `<ol>\n${tl.map(it => `  <li>${escapeHtml(it)}</li>`).join("\n")}\n</ol>`
    : `<p class="muted">(Хронология не заполнена)</p>`;

  return `<!--
  AUTOGENERATED FILE
  - edited via UI: Управление клиентами
  - you can still add extra text, but try to keep the dossierData JSON script intact
-->

<h2>Номер клиента: ${escapeHtml(num)}</h2>

<p><strong>Кратко:</strong> ${escapeHtml(dossier?.summary || "")}</p>

<h3>Справка</h3>
<ul>
  <li>Категория: ${escapeHtml(dossier?.category || "")}</li>
  <li>Приоритет: ${escapeHtml(dossier?.priority || "")}</li>
  <li>Ответственный: ${escapeHtml(dossier?.responsible || "")}</li>
</ul>

<h3>Хронология</h3>
${timelineHtml}

<h3>Заметки</h3>
<p>${escapeHtml(dossier?.notes || "").replaceAll("\n", "<br>")}</p>

<script type="application/json" id="dossierData">${escapeHtml(JSON.stringify(payload))}</script>
`;
}

async function readDossierDataFromFile(absPath) {
  try {
    const html = await fsp.readFile(absPath, "utf8");
    // IMPORTANT: match only the real JSON script (avoid matching comment text)
    const m = html.match(/<script[^>]*\btype=["']application\/json["'][^>]*\bid=["']dossierData["'][^>]*>([\s\S]*?)<\/script>/i);
    if (m) {
      const jsonText = m[1]
        .replace(/&lt;/g, "<")
        .replace(/&gt;/g, ">")
        .replace(/&quot;/g, '"')
        .replace(/&#039;/g, "'")
        .replace(/&amp;/g, "&")
        .trim();
      const parsed = JSON.parse(jsonText);
      return parsed?.dossier || parsed || {};
    }
  } catch {
    // ignore
  }
  return {
    summary: "",
    category: "",
    priority: "",
    responsible: "",
    timeline: [],
    notes: ""
  };
}

function photoDeletionTarget(client, id) {
  const cid = normId(id);
  const rel = String(client?.photo || "");
  if (!rel.startsWith("assets/clients/photos/")) return null;
  const base = path.basename(rel).toLowerCase();
  if (base.includes("placeholder")) return null;
  if (!base.startsWith(cid + ".")) return null;
  const abs = safeJoin(PHOTOS_DIR, base);
  return abs;
}

async function apiHandler(req, res, pathname) {
  // routing
  const parts = pathname.split("/").filter(Boolean); // [api, ...]
  const sub = parts.slice(1); // after 'api'

  // /api/clients
  if (sub.length === 1 && sub[0] === "clients") {
    if (req.method !== "GET") return sendJson(res, 405, { error: "Method not allowed" });
    const clients = await readJsonFile(CLIENTS_JSON, []);
    return sendJson(res, 200, Array.isArray(clients) ? clients : []);
  }

  // /api/client (POST)
  if (sub.length === 1 && sub[0] === "client") {
    if (req.method !== "POST") return sendJson(res, 405, { error: "Method not allowed" });

    let body;
    try {
      body = await readBodyJson(req);
    } catch (e) {
      if (String(e?.message) === "PAYLOAD_TOO_LARGE") return sendJson(res, 413, { error: "Payload too large" });
      if (String(e?.message) === "BAD_JSON") return sendJson(res, 400, { error: "Bad JSON" });
      return sendJson(res, 400, { error: "Bad request" });
    }

    const id = normId(body?.client?.id);
    if (!isValidClientId(id)) return sendJson(res, 400, { error: "Invalid id. Expected c###" });

    const clients = await readJsonFile(CLIENTS_JSON, []);
    if (Array.isArray(clients) && clients.some(c => normId(c.id) === id)) {
      return sendJson(res, 409, { error: `Client ${id} already exists` });
    }

    const paths = computePathsForId(id);

    const rawRating = body?.client?.rating;
    const ratingNum = (rawRating === "" || rawRating === null || rawRating === undefined)
      ? ""
      : Number(rawRating);
    const rating = Number.isFinite(ratingNum) ? ratingNum : "";

    const newClient = {
      id,
      firstName: body?.client?.firstName || "",
      middleName: body?.client?.middleName || "",
      lastName: body?.client?.lastName || "",
      rating,
      status: body?.client?.status || "",
      dob: body?.client?.dob || "",
      email: body?.client?.email || "",
      address: body?.client?.address || "",
      photo: body?.client?.photo || "assets/clients/photos/placeholder.svg",
      dossier: paths.dossier,
      audio: paths.audio,
      transcript: paths.transcript
    };

    await fsp.mkdir(DOSSIERS_DIR, { recursive: true });
    const dossierAbs = path.join(PUBLIC_DIR, paths.dossier);
    const dossierHtml = buildDossierHtml({ id, client: newClient, dossier: body?.dossier || {} });
    await fsp.writeFile(dossierAbs, dossierHtml, "utf8");

    const next = Array.isArray(clients) ? clients.slice() : [];
    next.push(newClient);
    await writeJsonFile(CLIENTS_JSON, next);

    return sendJson(res, 200, { ok: true, id });
  }

  // /api/client/:id
  if (sub.length === 2 && sub[0] === "client") {
    const id = normId(sub[1]);
    if (!isValidClientId(id)) return sendJson(res, 400, { error: "Invalid id. Expected c###" });

    const clients = await readJsonFile(CLIENTS_JSON, []);
    const arr = Array.isArray(clients) ? clients : [];
    const idx = arr.findIndex(c => normId(c.id) === id);
    if (idx < 0) return sendJson(res, 404, { error: `Client ${id} not found` });

    if (req.method === "GET") {
      const client = arr[idx];
      const dossierAbs = path.join(PUBLIC_DIR, client.dossier || computePathsForId(id).dossier);
      const dossier = await readDossierDataFromFile(dossierAbs);
      return sendJson(res, 200, { client, dossier });
    }

    if (req.method === "PUT") {
      let body;
      try {
        body = await readBodyJson(req);
      } catch (e) {
        if (String(e?.message) === "PAYLOAD_TOO_LARGE") return sendJson(res, 413, { error: "Payload too large" });
        if (String(e?.message) === "BAD_JSON") return sendJson(res, 400, { error: "Bad JSON" });
        return sendJson(res, 400, { error: "Bad request" });
      }

      const oldId = id;
      const requestedId = normId(body?.client?.id || oldId);
      if (!isValidClientId(requestedId)) return sendJson(res, 400, { error: "Invalid id. Expected c###" });

      if (requestedId !== oldId) {
        const exists = arr.some((c, i) => i !== idx && normId(c.id) === requestedId);
        if (exists) return sendJson(res, 409, { error: `Client ${requestedId} already exists` });
      }

      const rawRating = body?.client?.rating;
      const ratingNum = (rawRating === "" || rawRating === null || rawRating === undefined)
        ? ""
        : Number(rawRating);
      const rating = Number.isFinite(ratingNum) ? ratingNum : "";

      const oldClient = arr[idx];
      const paths = computePathsForId(requestedId);

      // photo: keep user-provided path; if we're renaming and the previous photo is id-based,
      // try to rename the underlying file and update the path automatically.
      let photo = (body?.client?.photo ?? oldClient?.photo ?? "").trim();
      if (!photo) photo = "assets/clients/photos/placeholder.svg";

      if (requestedId !== oldId) {
        const prevRel = String(oldClient?.photo || "");
        const prevBase = path.basename(prevRel).toLowerCase();
        const prevCid = normId(oldId);
        const nextCid = normId(requestedId);

        const isPrevIdPhoto = prevRel.startsWith("assets/clients/photos/") &&
          !prevBase.includes("placeholder") &&
          prevBase.startsWith(prevCid + ".");

        const userDidNotChangePhoto = (body?.client?.photo == null) || (String(body?.client?.photo) === String(oldClient?.photo));

        if (isPrevIdPhoto && userDidNotChangePhoto) {
          const ext = path.extname(prevBase) || ".png";
          const oldPhotoAbs = safeJoin(PHOTOS_DIR, prevBase);
          const newBase = `${nextCid}${ext}`;
          const newPhotoAbs = safeJoin(PHOTOS_DIR, newBase);
          if (oldPhotoAbs && newPhotoAbs) {
            try {
              await fsp.rename(oldPhotoAbs, newPhotoAbs);
              photo = `assets/clients/photos/${newBase}`;
            } catch {
              // if rename fails (file missing), keep previous path
              photo = prevRel || photo;
            }
          }
        }

        // If photo path still references oldId filename, update it to requestedId (same extension).
        if (typeof photo === "string" && photo.startsWith("assets/clients/photos/")) {
          const b = path.basename(photo).toLowerCase();
          if (b.startsWith(prevCid + ".")) {
            const ext = path.extname(b) || ".png";
            photo = `assets/clients/photos/${nextCid}${ext}`;
          }
        }
      }

      // IMPORTANT: build the object explicitly so removed fields (e.g. phone) disappear on save.
      const updated = {
        id: requestedId,
        firstName: body?.client?.firstName || "",
        middleName: body?.client?.middleName || "",
        lastName: body?.client?.lastName || "",
        rating,
        status: body?.client?.status || "",
        dob: body?.client?.dob || "",
        email: body?.client?.email || "",
        address: body?.client?.address || "",
        photo,
        dossier: paths.dossier,
        audio: paths.audio,
        transcript: paths.transcript
      };

      // write dossier (to the requested id file)
      await fsp.mkdir(DOSSIERS_DIR, { recursive: true });
      const dossierAbs = path.join(PUBLIC_DIR, paths.dossier);
      const dossierHtml = buildDossierHtml({ id: requestedId, client: updated, dossier: body?.dossier || {} });
      await fsp.writeFile(dossierAbs, dossierHtml, "utf8");

      // if id changed, remove the old dossier file (we don't keep duplicates)
      if (requestedId !== oldId) {
        const oldDossierAbs = path.join(PUBLIC_DIR, oldClient.dossier || computePathsForId(oldId).dossier);
        if (oldDossierAbs !== dossierAbs) {
          try { await fsp.unlink(oldDossierAbs); } catch {}
        }
      }

      const next = arr.slice();
      next[idx] = updated;
      await writeJsonFile(CLIENTS_JSON, next);

      return sendJson(res, 200, { ok: true, id: requestedId, renamedFrom: requestedId !== oldId ? oldId : undefined });
    }

    if (req.method === "DELETE") {
      const client = arr[idx];
      const next = arr.slice();
      next.splice(idx, 1);
      await writeJsonFile(CLIENTS_JSON, next);

      // delete dossier
      const dossierAbs = path.join(PUBLIC_DIR, client.dossier || computePathsForId(id).dossier);
      try { await fsp.unlink(dossierAbs); } catch {}

      // delete photo if it looks like an id-specific file
      const photoAbs = photoDeletionTarget(client, id);
      if (photoAbs) {
        try { await fsp.unlink(photoAbs); } catch {}
      }

      return sendJson(res, 200, { ok: true, id });
    }

    return sendJson(res, 405, { error: "Method not allowed" });
  }

  return sendJson(res, 404, { error: "Unknown endpoint" });
}

const server = http.createServer(async (req, res) => {
  try {
    const url = new URL(req.url, `http://${req.headers.host}`);
    const pathname = decodeURIComponent(url.pathname);

    // API
    if (pathname.startsWith("/api/")) {
      return await apiHandler(req, res, pathname);
    }

    // Static
    let p = pathname;
    if (p === "/") p = "/index.html";

    const hasExt = path.extname(p) !== "";
    const requested = safeJoin(PUBLIC_DIR, p);
    if (!requested) {
      return send(res, 400, { "Content-Type": "text/plain; charset=utf-8" }, "Bad Request");
    }

    fs.stat(requested, (err, stat) => {
      if (!err && stat.isFile()) {
        return serveFile(req, res, requested);
      }

      if (!hasExt) {
        return serveFile(req, res, path.join(PUBLIC_DIR, "index.html"));
      }

      return send(res, 404, { "Content-Type": "text/plain; charset=utf-8" }, "Not Found");
    });
  } catch {
    return send(res, 500, { "Content-Type": "text/plain; charset=utf-8" }, "Server Error");
  }
});

server.listen(PORT, () => {
  console.log(`Offline UI server running: http://localhost:${PORT}`);
  console.log(`Public dir: ${PUBLIC_DIR}`);
});
